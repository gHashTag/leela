[["/Users/playra/leela/src/components/Avatar/Avatar.test.tsx",{"fileContent":"import React from 'react'\nimport { render, fireEvent } from '@testing-library/react-native'\n\nimport { Avatar, PressableAvatar } from './' // replace with your actual path\n\ndescribe('Avatar', () => {\n  it('should render loading state correctly', () => {\n    const { getByTestId } = render(<Avatar loading={true} />)\n    expect(getByTestId('avatar')).toBeTruthy()\n  })\n\n  it('should render image from uri correctly', () => {\n    const { getByTestId } = render(\n      <Avatar loading={false} uri=\"https://example.com/image.png\" />\n    )\n    expect(getByTestId('avatar')).toBeTruthy()\n  })\n})\n\ndescribe('PressableAvatar', () => {\n  it('should call onPress when pressed', () => {\n    const mockOnPress = jest.fn()\n    const { getByTestId } = render(\n      <PressableAvatar onPress={mockOnPress} loading={false} />\n    )\n\n    fireEvent.press(getByTestId('avatar'))\n    expect(mockOnPress).toHaveBeenCalled()\n  })\n})\n","resolvedModuleNames":["/Users/playra/leela/src/components/Avatar/index.tsx","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/components/Pressable/index.tsx"]}],["/Users/playra/leela/src/components/Avatar/index.tsx",{"fileContent":"/* eslint-disable react-native/no-unused-styles */\nimport React, { memo } from 'react'\n\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native'\nimport FastImage from 'react-native-fast-image'\nimport { s } from 'react-native-size-matters'\nimport Spinner from 'react-native-spinkit'\n\nimport { secondary } from '../../constants'\nimport { Pressable } from '../Pressable'\n\ntype sizeType = 'xLarge' | 'large' | 'medium' | 'small'\n\ninterface AvatarT {\n  loading: boolean\n  size?: sizeType\n  uri?: string\n  viewStyle?: StyleProp<ViewStyle>\n}\n\nexport const Avatar = memo<AvatarT>(\n  ({ loading, uri, size = 'large', viewStyle }) => {\n    return (\n      <View style={[styles.container, viewStyle]} testID=\"avatar\">\n        {loading ? (\n          <Spinner size={styles[size].height} type=\"Pulse\" color={secondary} />\n        ) : !uri ? (\n          <FastImage style={styles[size]} source={require('./pickaface.png')} />\n        ) : (\n          <FastImage\n            style={styles[size]}\n            source={{ uri, priority: FastImage.priority.high }}\n          />\n        )}\n      </View>\n    )\n  }\n)\n\ninterface PressableAvatarT extends AvatarT {\n  onPress?: () => void\n}\n\nexport const PressableAvatar = ({ onPress, ...props }: PressableAvatarT) => {\n  return (\n    <Pressable onPress={onPress}>\n      <Avatar {...props} />\n    </Pressable>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignSelf: 'center',\n    borderRadius: s(130),\n    overflow: 'hidden'\n  },\n  xLarge: {\n    marginLeft: 1,\n    width: s(120),\n    height: s(120),\n    borderRadius: s(130)\n  },\n  large: {\n    marginLeft: 1,\n    width: s(75),\n    height: s(75),\n    borderRadius: s(75)\n  },\n  medium: {\n    width: s(50),\n    height: s(50),\n    borderRadius: s(50)\n  },\n  small: {\n    width: s(36),\n    height: s(36),\n    borderRadius: s(36)\n  }\n})\n","resolvedModuleNames":["/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/components/Pressable/index.tsx","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/types.ts"]}],["/Users/playra/leela/src/components/Space/Space.test.tsx",{"fileContent":"// Import libraries\nimport React from 'react'\nimport { render } from '@testing-library/react-native'\n\n// Import the component to be tested\nimport { Space } from './'\n\ndescribe('Space', () => {\n  it('renders correctly with default props', () => {\n    const { getByTestId } = render(<Space />)\n    const spaceComponent = getByTestId('space-component')\n\n    expect(spaceComponent.props.style).toEqual({ height: 0, width: 0 })\n  })\n\n  it('renders correctly with given height and width', () => {\n    const { getByTestId } = render(<Space height={10} width={20} />)\n    const spaceComponent = getByTestId('space-component')\n\n    expect(spaceComponent.props.style).toEqual({ height: 10, width: 20 })\n  })\n})\n","resolvedModuleNames":["/Users/playra/leela/src/components/Space/index.tsx"]}],["/Users/playra/leela/src/constants.ts",{"fileContent":"//@ts-expect-error\nimport { LEELA_ID, OPEN_AI_KEY } from '@env'\nimport { createNavigationContainerRef } from '@react-navigation/native'\nimport * as Sentry from '@sentry/react-native'\nimport axios from 'axios'\nimport { Alert, Dimensions, Linking, Platform } from 'react-native'\nimport Rate from 'react-native-rate'\nimport i18next from './i18n'\n\nimport { PostStore } from './store'\nimport { ButtonsModalT, HandleCommentAiParamsT, MessageAIT } from './types'\n\nexport const navRef = createNavigationContainerRef<any>()\n\nexport const navigate = (name: string, params?: any) => {\n  if (navRef.isReady()) {\n    navRef.navigate(name, params)\n  }\n}\n\nexport const generateComment = async ({\n  message,\n  systemMessage,\n  planText\n}: MessageAIT): Promise<string> => {\n  try {\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-4-0314',\n        messages: [\n          {\n            role: 'system',\n            content: systemMessage\n          },\n          {\n            role: 'user',\n            content: message\n          },\n          {\n            role: 'assistant',\n            content: planText\n          }\n        ],\n        max_tokens: 1000,\n        temperature: 0.5\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${OPEN_AI_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    )\n\n    return response?.data?.choices[0]?.message?.content ?? ''\n  } catch (error) {\n    captureException(error, 'generateComment')\n    throw error\n  }\n}\n\nexport const onLeaveFeedback = (onAction: (success: any) => void) => {\n  const options = {\n    AppleAppID: '1296604457',\n    GooglePackageName: 'com.leelagame',\n    OtherAndroidURL:\n      'https://play.google.com/store/apps/details?id=com.leelagame',\n    preferInApp: true,\n    openAppStoreIfInAppFails: true\n  }\n  Rate.rate(options, onAction)\n}\n\nexport const handleCommentAi = async ({\n  curItem,\n  systemMessage,\n  message,\n  planText = ' '\n}: HandleCommentAiParamsT): Promise<void> => {\n  const aiComment: string = await generateComment({\n    message,\n    systemMessage,\n    planText\n  })\n  if (curItem && aiComment) {\n    await PostStore.createComment({\n      text: aiComment,\n      postId: curItem.id,\n      postOwner: curItem.ownerId,\n      ownerId: LEELA_ID\n    })\n  }\n}\n\nexport function OpenNetworkModal() {\n  if (navRef.isReady()) {\n    navRef.navigate('NETWORK_MODAL')\n  }\n}\n\nexport function OpenUpdateVersionModal() {\n  if (navRef.isReady()) {\n    navRef.navigate('UPDATE_VERSION_MODAL')\n  }\n}\n\nexport function OpenExitModal() {\n  if (navRef.isReady()) {\n    navRef.navigate('EXIT_MODAL')\n  }\n}\n\ninterface VideoModalT {\n  uri: string\n  poster: string\n}\n\nexport function OpenVideoModal({ uri, poster }: VideoModalT) {\n  if (navRef.isReady()) {\n    navRef.navigate('VIDEO_SCREEN', { uri, poster })\n  }\n}\n\nexport function OpenPlanReportModal(plan: number) {\n  if (navRef.isReady()) {\n    navRef.navigate('PLAN_REPORT_MODAL', { plan })\n  }\n}\n\nexport function OpenActionsModal(modalButtons: ButtonsModalT[]) {\n  if (navRef.isReady()) {\n    navRef.navigate('REPLY_MODAL', { buttons: modalButtons })\n  }\n}\n\nexport const banAlert = () => {\n  Alert.alert(\n    i18next.t('online-part.youBanned'),\n    i18next.t('online-part.banText'),\n    [{ text: 'OK', onPress: () => navigate('HELLO') }]\n  )\n}\nexport const accountHasBanAlert = () => {\n  Alert.alert(i18next.t('online-part.accountBanned'), undefined, [\n    { text: 'OK' }\n  ])\n}\n\nexport const captureException = (error: any, target: string) => {\n  if (!error) {\n    console.log(\n      '%c captureException called with messing or incorrect arguments',\n      'background: #555; color: yellow'\n    )\n    return\n  }\n  console.error(`On:${target}/ My Error: ${error} `)\n  if (!__DEV__) {\n    Sentry.captureException(error)\n  }\n}\n\nexport const win = Dimensions.get('window')\nexport const W = win.width\nexport const H = win.height\nexport const imgH = Math.round((W * 9) / 16)\nexport const isIos = Platform.OS === 'ios'\n\nexport const openUrl = async (url: string) => {\n  await Linking.openURL(url)\n}\n\nexport const goBack = () => {\n  if (navRef.isReady()) {\n    navRef.goBack()\n  }\n}\n//@ts-ignore\nexport const goHome = (navigation) => () => navigation.popToTop()()\n\nexport const primary = '#50E3C2'\nexport const secondary = '#ff06f4'\nexport const gray = '#949494'\nexport const white = '#ffffff'\nexport const black = '#1c1c1c'\nexport const dimGray = '#707070'\nexport const lightGray = '#D1CDCD'\nexport const classicRose = '#FDBEEA'\nexport const mustard = '#F3DE50'\nexport const fuchsia = '#FF06F4'\nexport const trueBlue = '#007ACD'\nexport const paleBlue = '#BEFCE5'\nexport const brightTurquoise = '#1EE4EC'\nexport const red = '#FC2847'\nexport const orange = '#FFB700'\nexport const blackOpacity = 'rgba(0, 0, 0, 0.8)'\nexport const grayBlackOpacity = 'rgba(139, 139, 139, 0.1)'\n\nexport const revenuecat = 'BeIMIIfptWXlouosYudFEWQDkwDvJUzv'\n\nexport const defUrl =\n  'https://leelachakra.com/resource/LeelaChakra/Mantra/mantra.json'\n\nexport const ENTITLEMENT_ID = 'Pro'\n","resolvedModuleNames":["/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/src/store/PostStore.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/DiceStore.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/OfflinePlayers.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/store/BadgeAndroidStore.ts","/Users/playra/leela/src/store/SubscribeStore.ts"]}],["/Users/playra/leela/src/components/Space/index.tsx",{"fileContent":"import React, { memo } from 'react'\n\nimport { View } from 'react-native'\n\ninterface SpaceT {\n  height?: number | string\n  width?: number | string\n}\n\nconst Space = memo<SpaceT>(({ height, width }) => (\n  <View\n    testID=\"space-component\"\n    style={{ height: Number(height) || 0, width: Number(width) || 0 }}\n  />\n))\n\nexport { Space }\n","resolvedModuleNames":[]}],["/Users/playra/leela/src/i18n.ts",{"fileContent":"import i18next from 'i18next'\nimport { isoCountry } from 'iso-country'\nimport { initReactI18next } from 'react-i18next'\nimport * as RNLocalize from 'react-native-localize'\n\nimport ar from './locales/ar/translation.json'\nimport bn from './locales/bn/translation.json'\nimport en from './locales/en/translation.json'\nimport fr from './locales/fr/translation.json'\nimport mr from './locales/mr/translation.json'\nimport ms from './locales/ms/translation.json'\nimport ru from './locales/ru/translation.json'\nimport te from './locales/te/translation.json'\nimport tr from './locales/tr/translation.json'\nimport uk from './locales/uk/translation.json'\n\nconst locales = RNLocalize.getLocales()\n\nif (!Array.isArray(locales) || locales.length === 0) {\n  throw new Error('No locales found')\n}\n\nexport const lang = locales[0]?.languageCode\nif (!lang) {\n  throw new Error('No language code found for first locale')\n}\n\nexport const flagEmoji = isoCountry(locales[0]?.countryCode)?.emoji ?? '🇷🇺'\n\nconst resources = {\n  ar: {\n    translation: ar\n  },\n  bn: {\n    translation: bn\n  },\n  en: {\n    translation: en\n  },\n  fr: {\n    translation: fr\n  },\n  mr: {\n    translation: mr\n  },\n  ms: {\n    translation: ms\n  },\n  ru: {\n    translation: ru\n  },\n  te: {\n    translation: te\n  },\n  tr: {\n    translation: tr\n  },\n  uk: {\n    translation: uk\n  }\n}\n\nfor (const [key, value] of Object.entries(resources)) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error(`Invalid locale data for language ${key}`)\n  }\n}\n\nexport const supportedLngs = [\n  'ar',\n  'bn',\n  'en',\n  'fr',\n  'mr',\n  'ms',\n  'ru',\n  'te',\n  'tr',\n  'uk'\n]\n\nexport const isSupportedLang = supportedLngs.includes(lang)\nexport const ruOrEnLang = lang === 'ru' ? 'ru' : 'en'\n\ni18next.use(initReactI18next).init(\n  {\n    compatibilityJSON: 'v3',\n    resources,\n    lng: isSupportedLang ? lang : ruOrEnLang,\n    debug: __DEV__,\n    interpolation: {\n      escapeValue: true\n    },\n    react: {\n      useSuspense: false\n    }\n    // keySeparator: false,\n  },\n  (err) => {\n    if (err) {\n      __DEV__ && console.error('Error initializing i18next:', err)\n    }\n  }\n)\n\nexport default i18next\n","resolvedModuleNames":["/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json"]}],["/Users/playra/leela/src/store/index.ts",{"fileContent":"// сверху ерунда\nexport * from './PostStore'\nexport * from './MessagingStore'\nexport * from './DiceStore'\nexport * from './OnlinePlayer'\nexport * from './OfflinePlayers'\nexport * from './OtherPlayers'\nexport * from './BadgeAndroidStore'\nexport * from './SubscribeStore'\n","resolvedModuleNames":["/Users/playra/leela/src/store/PostStore.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/DiceStore.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/OfflinePlayers.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/store/BadgeAndroidStore.ts","/Users/playra/leela/src/store/SubscribeStore.ts","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/src/store/helper.ts","/Users/playra/leela/src/store/index.ts"]}],["/Users/playra/leela/src/store/PostStore.ts",{"fileContent":"// @ts-ignore\nimport { LEELA_ID, YANDEX_FOLDER_ID, YANDEX_TRANSLATE_API_KEY } from '@env'\nimport auth from '@react-native-firebase/auth'\nimport firestore, {\n  FirebaseFirestoreTypes\n} from '@react-native-firebase/firestore'\nimport { makeAutoObservable } from 'mobx'\nimport { nanoid } from 'nanoid/non-secure'\nimport { captureException, generateComment } from '../constants'\nimport i18next from '../i18n'\nimport { flagEmoji, lang } from '../i18n'\nimport { getProfile, getUid } from '../screens/helper'\nimport { OnlinePlayer } from '../store/OnlinePlayer'\nimport { OtherPlayers } from '../store/OtherPlayers'\n\nimport {\n  CommentT,\n  FormCommentT,\n  FormPostT,\n  FormReplyCom,\n  PostT,\n  ReplyComT\n} from '../types'\n\ntype fetchT =\n  FirebaseFirestoreTypes.QuerySnapshot<FirebaseFirestoreTypes.DocumentData>\ninterface postStoreT {\n  posts: PostT[]\n  ownPosts: PostT[]\n  comments: CommentT[]\n  replyComments: ReplyComT[]\n  loadPosts: boolean\n  loadOwnPosts: boolean\n  myCountPosts: number\n}\n\ninterface delCommentT {\n  commentId: string\n  isReply: boolean\n  postId?: string\n}\n\ninterface delCommentIdT {\n  commentId: string\n  postId?: string\n}\n\nconst limit = 6\n\nexport const PostStore = {\n  store: makeAutoObservable<postStoreT>({\n    posts: [],\n    ownPosts: [],\n    comments: [],\n    replyComments: [],\n    loadOwnPosts: true,\n    loadPosts: true,\n    myCountPosts: 0\n  }),\n  countPosts: async () => {\n    try {\n      const userUid = auth().currentUser?.uid\n      firestore()\n        .collection('Posts')\n        .where('ownerId', '==', userUid)\n        .orderBy('createTime', 'desc')\n        .limit(limit)\n        .onSnapshot((querySnapshot) => {\n          // On each change, fetch own posts\n          PostStore.fetchOwnPosts(querySnapshot)\n          PostStore.store.myCountPosts = querySnapshot.size\n        })\n      return PostStore.store.myCountPosts\n    } catch (error) {\n      captureException(error, 'getNumberOfPosts')\n    }\n  },\n  createPost: async ({ text, plan, systemMessage, planText }: FormPostT) => {\n    const userUid = auth().currentUser?.uid\n    const email = auth().currentUser?.email\n    if (userUid && email) {\n      const id = nanoid()\n      const post: PostT = {\n        systemMessage,\n        text,\n        plan,\n        id,\n        createTime: Date.now(),\n        email,\n        comments: [],\n        liked: [],\n        accept: true,\n        language: lang,\n        flagEmoji,\n        planText,\n        ownerId: userUid\n      }\n      try {\n        await firestore().collection('Posts').doc(id).set(post)\n        const docSnapshot = await firestore().collection('Posts').doc(id).get()\n        if (docSnapshot.exists) {\n          const createdPostData = docSnapshot.data()\n          const textMessage: string =\n            createdPostData === undefined ? null : createdPostData.text\n          await generateComment({\n            message: textMessage,\n            systemMessage,\n            planText\n          })\n          return createdPostData\n        } else {\n          return null\n        }\n      } catch (error) {\n        captureException(error, 'createPost')\n        throw error\n      }\n    }\n    throw new Error('Missing userUid or email')\n  },\n\n  createComment: async ({ text, postId, postOwner, ownerId }: FormCommentT) => {\n    try {\n      const userUid = ownerId !== LEELA_ID ? auth().currentUser?.uid : ownerId\n\n      const email = auth().currentUser?.email\n      const path = nanoid(22)\n      if (userUid && email) {\n        const comment: CommentT = {\n          text,\n          postId,\n          postOwner,\n          firstName: OnlinePlayer.store.profile.firstName,\n          lastName: OnlinePlayer.store.profile.lastName,\n          ownerId: userUid,\n          createTime: Date.now(),\n          email: email,\n          reply: false,\n          id: path\n        }\n\n        await firestore()\n          .collection('Posts')\n          .doc(postId)\n          .update({ comments: firestore.FieldValue.arrayUnion(path) })\n        await firestore().collection('Comments').doc(path).set(comment)\n      }\n    } catch (error) {\n      captureException(error, 'createComment')\n      throw error\n    }\n  },\n  removeCommentIdInPost: async ({ commentId, postId }: delCommentIdT) => {\n    postId &&\n      firestore()\n        .collection('Posts')\n        .doc(postId)\n        .update({ comments: firestore.FieldValue.arrayRemove(commentId) })\n  },\n  delComment: async ({ commentId, isReply, postId }: delCommentT) => {\n    await firestore().collection('Comments').doc(commentId).delete()\n    PostStore.store.comments = PostStore.store.comments.filter(\n      (a) => a.id !== commentId\n    )\n    PostStore.removeCommentIdInPost({ commentId, postId })\n    if (!isReply) {\n      firestore()\n        .collection('Comments')\n        .where('commentId', '==', commentId)\n        .get()\n        .then(function (querySnap) {\n          querySnap.forEach(function (doc) {\n            const data = doc.data()\n            PostStore.removeCommentIdInPost({ commentId: data.id, postId })\n            doc.ref.delete()\n          })\n        })\n    }\n  },\n  replyComment: async ({\n    text,\n    commentId,\n    postId,\n    commentOwner\n  }: FormReplyCom) => {\n    const userUid = auth().currentUser?.uid\n    const prof = await getProfile()\n    if (prof) {\n      const path = nanoid(23)\n      if (userUid) {\n        const comment: ReplyComT = {\n          text,\n          postId,\n          commentId,\n          commentOwner,\n          firstName: prof.firstName,\n          lastName: prof.lastName,\n          ownerId: userUid,\n          createTime: Date.now(),\n          email: prof.email,\n          reply: true,\n          id: path\n        }\n        await firestore()\n          .collection('Posts')\n          .doc(postId)\n          .update({ comments: firestore.FieldValue.arrayUnion(path) })\n        await firestore().collection('Comments').doc(path).set(comment)\n      }\n    }\n  },\n  fetchPosts: async (querySnap: fetchT) => {\n    PostStore.store.loadPosts = true\n    const uid = getUid()\n    const isAdmin = OnlinePlayer.store.status === 'Admin'\n    const res: any[] = querySnap.docs\n      .map((a) => {\n        if (a.exists) {\n          const data = a.data()\n          return data\n        }\n      })\n      .filter((a) => a !== undefined)\n      .filter((a) => (isAdmin ? true : a?.ownerId === uid ? true : a?.accept))\n    if (res.length > 0) {\n      PostStore.store.posts = res.sort((a, b) => b.createTime - a.createTime)\n    }\n    PostStore.store.loadPosts = false\n  },\n  fetchOwnPosts: async (querySnap: fetchT) => {\n    PostStore.store.loadOwnPosts = true\n    const uid = getUid()\n    const res: any[] = querySnap.docs\n      .map((a) => {\n        if (a.exists) {\n          const data = a.data()\n          return data\n        }\n      })\n      .filter((a) => a !== undefined)\n      .filter((a) => a?.ownerId === uid)\n    if (res.length > 0) {\n      PostStore.store.ownPosts = res.sort((a, b) => b.createTime - a.createTime)\n    }\n    PostStore.store.loadOwnPosts = false\n  },\n  fetchComments: async (querySnap: fetchT) => {\n    const res: any[] = await Promise.all(\n      querySnap.docs\n        .map(async (a) => {\n          if (a.exists) {\n            const data = a.data()\n            return data\n          }\n        })\n        .filter((a: any) => a !== undefined)\n      // (a !== undefined ? (a.reply ? false : true) : false)\n    )\n    if (res.length > 0) {\n      PostStore.store.comments = res\n        .filter((a) => (a.reply ? false : true))\n        .sort((a, b) => b.createTime - a.createTime)\n      PostStore.store.replyComments = res\n        .filter((a) => (a.reply ? true : false))\n        .sort((a, b) => a.createTime - b.createTime)\n    }\n  },\n  likePost: async (postId: string) => {\n    const userUid = auth().currentUser?.uid\n    await firestore()\n      .collection('Posts')\n      .doc(postId)\n      .update({\n        liked: firestore.FieldValue.arrayUnion(userUid)\n      })\n  },\n  unlikePost: async (postId: string) => {\n    const userUid = auth().currentUser?.uid\n    await firestore()\n      .collection('Posts')\n      .doc(postId)\n      .update({\n        liked: firestore.FieldValue.arrayRemove(userUid)\n      })\n  },\n  getOwnerName: (ownerId: string, full?: boolean) => {\n    const userUid = auth().currentUser?.uid\n    const displayName = auth().currentUser?.displayName\n    if (userUid === ownerId) {\n      return displayName\n    }\n    const profile = OtherPlayers.store.players.find((a) => a.owner === ownerId)\n    if (!profile) {\n      return i18next.t('anonymous')\n    }\n    return full !== false\n      ? `${profile.firstName} ${profile.lastName}`\n      : `${profile.firstName}`\n  },\n  getComPlan: (ownerId: string) => {\n    const userUid = getUid()\n    if (userUid === ownerId) {\n      return OnlinePlayer.store.plan\n    }\n    const plan = OtherPlayers.store.players.find((a) => a.owner === ownerId)\n      ?.plan\n    if (!plan) {\n      return 0\n    }\n    return plan\n  },\n  getOncePost: async () => {\n    await firestore()\n      .collection('Profiles')\n      .get()\n      .then((snap) => OtherPlayers.getOtherProf({ snapshot: snap }))\n    await firestore().collection('Posts').get().then(PostStore.fetchPosts)\n  },\n  translateText: async (text: string) => {\n    try {\n      const res = await (\n        await fetch(\n          'https://translate.api.cloud.yandex.net/translate/v2/translate',\n          {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              Authorization: `Api-Key ${YANDEX_TRANSLATE_API_KEY}`\n            },\n            body: JSON.stringify({\n              folderId: YANDEX_FOLDER_ID,\n              texts: text,\n              targetLanguageCode: lang\n            })\n          }\n        )\n      ).json()\n      if (res?.translations && res.translations?.length > 0) {\n        return res.translations[0].text\n      }\n    } catch (err) {\n      captureException(err, 'translateText')\n    }\n    return text\n  },\n  getAvaById: (uid: string) => {\n    const userUid = getUid()\n    if (userUid === uid) {\n      return OnlinePlayer.store.avatar\n    }\n    const otherUserAva = OtherPlayers.store.players.find((a) => a.owner === uid)\n      ?.avatar\n    return otherUserAva\n      ? otherUserAva\n      : 'https://bafkreiftrmfmimlvo26xaxfvt2ypnjjaavq5mgnkjljs6mczfekii4cmtq.ipfs.nftstorage.link/'\n  },\n  banUnbanUser: async (uid: string) => {\n    try {\n      const profile = (\n        await firestore().collection('Profiles').doc(uid).get()\n      ).data()\n      if (profile && profile.status !== 'Admin') {\n        if (profile.status === 'ban') {\n          firestore().collection('Profiles').doc(uid).update({ status: null })\n        } else {\n          firestore().collection('Profiles').doc(uid).update({ status: 'ban' })\n        }\n      }\n    } catch (error) {\n      captureException(error, 'banUnbanUser')\n    }\n  },\n  delPost: (id: string) => {\n    firestore()\n      .collection('Comments')\n      .where('postId', '==', id)\n      .get()\n      .then((querySnap) => {\n        querySnap.forEach(async (doc) => {\n          const data = doc.data()\n          const comId = data.id\n          PostStore.delComment({ commentId: comId, isReply: true })\n        })\n      })\n    firestore().collection('Posts').doc(id).delete()\n  },\n  delAllUserPosts: async (userUid: string) => {\n    firestore()\n      .collection('Posts')\n      .where('ownerId', '==', userUid)\n      .get()\n      .then((querySnap) => {\n        querySnap.forEach(async (doc) => {\n          const postId = doc.data().id\n          PostStore.delPost(postId)\n        })\n      })\n  },\n  delAllUserComments: async (userUid: string) => {\n    firestore()\n      .collection('Comments')\n      .where('ownerId', '==', userUid)\n      .get()\n      .then((querySnap) => {\n        querySnap.forEach(async (doc) => {\n          const data = doc.data()\n          const commentId = data.id\n          const isReply = data.reply\n          const postId = data.postId\n          PostStore.delComment({ commentId, isReply, postId })\n        })\n      })\n  },\n  acceptPost: (isAccept: boolean, postId: string) => {\n    firestore().collection('Posts').doc(postId).update({ accept: !isAccept })\n  }\n}\n","resolvedModuleNames":["/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/package.json","/Users/playra/leela/src/store/helper.ts","/Users/playra/leela/src/store/MessagingStore.ts"]}],["/Users/playra/leela/src/screens/helper.ts",{"fileContent":"import auth, { FirebaseAuthTypes } from '@react-native-firebase/auth'\nimport {\n  FirebaseDatabaseTypes,\n  firebase\n} from '@react-native-firebase/database'\nimport firestore from '@react-native-firebase/firestore'\nimport storage from '@react-native-firebase/storage'\nimport { nanoid } from 'nanoid/non-secure'\nimport ImagePicker from 'react-native-image-crop-picker'\nimport semver from 'semver'\nimport {\n  OpenPlanReportModal,\n  OpenUpdateVersionModal,\n  accountHasBanAlert,\n  captureException,\n  navigate\n} from '../constants'\nimport i18next, { flagEmoji, lang } from '../i18n'\nimport {\n  MessagingStore,\n  OnlinePlayer,\n  actionsDice,\n  fetchBusinesses\n} from '../store'\nimport { HistoryT, UserT } from '../types'\n\nimport { version } from '../../package.json'\n\ninterface NewProfileI {\n  email: string\n  uid: string\n  firstName: string\n  lastName: string\n}\n\n//firebase help\n\nconst getFireBaseRef = (path: string): FirebaseDatabaseTypes.Reference => {\n  return firebase\n    .app()\n    .database(\n      'https://leela-chakra-default-rtdb.europe-west1.firebasedatabase.app/'\n    )\n    .ref(path)\n}\n\n// Profile operations\n\nconst getProfile = async (): Promise<UserT | undefined> => {\n  const userUid = auth().currentUser?.uid\n  let res\n  try {\n    const response = await firestore().collection('Profiles').doc(userUid).get()\n    res = response.data() as UserT\n  } catch (err) {\n    captureException(err, 'getProfile')\n  }\n  return res\n}\n\nconst onWin = async () => {\n  const userUid = auth().currentUser?.uid\n  firestore().collection('Profiles').doc(userUid).update({\n    firstGame: false,\n    finish: true,\n    start: false\n  })\n}\n\nconst onStart = async () => {\n  const userUid = auth().currentUser?.uid\n  firestore().collection('Profiles').doc(userUid).update({\n    start: true\n  })\n}\n\nconst createProfile = async ({\n  email,\n  uid,\n  firstName,\n  lastName\n}: NewProfileI) => {\n  const hisObj: HistoryT[] = [\n    {\n      count: 0,\n      plan: 68,\n      status: 'start',\n      createDate: Date.now()\n    }\n  ]\n  await firestore()\n    .collection('Profiles')\n    .doc(uid)\n    .set({\n      email,\n      owner: uid,\n      firstName,\n      lastName,\n      plan: 68,\n      lastStepTime: Date.now() - 86400000,\n      start: false,\n      finish: false,\n      firstGame: true,\n      history: hisObj,\n      lang,\n      flagEmoji,\n      isReported: true\n    })\n  OnlinePlayer.store = {\n    ...OnlinePlayer.store,\n    plan: 68,\n    profile: {\n      firstName,\n      lastName,\n      email,\n      intention: ''\n    },\n    stepTime: Date.now() - 86400000,\n    canGo: true,\n    history: hisObj,\n    start: false,\n    finish: false,\n    firstGame: true\n  }\n}\n\nconst updateFlagEmojiIfNeed = async () => {\n  const userUid = auth().currentUser?.uid\n  if (OnlinePlayer.store.flagEmoji !== flagEmoji) {\n    await firestore().collection('Profiles').doc(userUid).update({ flagEmoji })\n    OnlinePlayer.store.flagEmoji = flagEmoji\n  }\n}\n\nconst updatePlan = async (plan: number) => {\n  const userUid = auth().currentUser?.uid\n  if (userUid) {\n    await firestore()\n      .collection('Profiles')\n      .doc(userUid)\n      .update({\n        plan\n      })\n      .catch((error) => captureException(error, 'updatePlan'))\n  }\n}\n\nconst resetPlayer = async () => {\n  const userUid = auth().currentUser?.uid\n  await firestore()\n    .collection('Profiles')\n    .doc(userUid)\n    .update({\n      start: false,\n      finish: false\n    })\n    .catch((error) => captureException(error, 'resetPlayer'))\n}\n\ninterface profNameI {\n  firstName: string\n  lastName: string\n}\nconst updateProfName = async ({ firstName, lastName }: profNameI) => {\n  try {\n    await auth().currentUser?.updateProfile({\n      displayName: `${firstName} ${lastName}`\n    })\n    await firestore().collection('Profiles').doc(getUid()).update({\n      firstName,\n      lastName\n    })\n    await auth().currentUser?.reload()\n    OnlinePlayer.store.profile.firstName = firstName\n    OnlinePlayer.store.profile.lastName = lastName\n  } catch (err) {\n    captureException(err, 'updateProfName')\n  }\n}\nconst updateIntention = async (newIntention: string) => {\n  try {\n    await firestore().collection('Profiles').doc(getUid()).update({\n      intention: newIntention\n    })\n    OnlinePlayer.store.profile.intention = newIntention\n  } catch (err) {\n    captureException(err, 'updateIntention')\n  }\n}\n\nconst isLoggedIn = async () => {\n  if (auth().currentUser) {\n    return true\n  } else {\n    return false\n  }\n}\n\nconst resetHistory = async () => {\n  const userUid = auth().currentUser?.uid\n  const hist: HistoryT[] = [\n    {\n      createDate: Date.now(),\n      plan: 68,\n      count: 0,\n      status: 'start'\n    }\n  ]\n  await firestore().collection('Profiles').doc(userUid).update({\n    history: hist\n  })\n}\n\nconst createHistory = async (values: HistoryT) => {\n  try {\n    const userUid = auth().currentUser?.uid\n    if (userUid) {\n      if (values.count !== 6) {\n        OnlinePlayer.store.canGo = false\n        OnlinePlayer.store.isReported = false\n        await firestore()\n          .collection('Profiles')\n          .doc(userUid)\n          .update({\n            isReported: false,\n            history: firestore.FieldValue.arrayUnion(values)\n          })\n      } else {\n        await firestore()\n          .collection('Profiles')\n          .doc(userUid)\n          .update({\n            history: firestore.FieldValue.arrayUnion(values)\n          })\n      }\n    }\n  } catch (err) {\n    captureException(err, 'createHistory')\n  }\n}\n\nconst startStepTimer = () => {\n  const newTime = Date.now()\n  OnlinePlayer.store.stepTime = newTime\n  OnlinePlayer.store.isReported = true\n  const userUid = getUid()\n  if (userUid) {\n    firestore().collection('Profiles').doc(userUid).update({\n      lastStepTime: newTime,\n      isReported: true\n    })\n  }\n}\n\n// Image operations\n\nconst getImagePicker = async () => {\n  const image = await ImagePicker.openPicker({\n    width: 400,\n    height: 400,\n    cropping: true,\n    cropperCircleOverlay: true,\n    sortOrder: 'none',\n    compressImageMaxWidth: 400,\n    compressImageMaxHeight: 400,\n    compressImageQuality: 1,\n    compressVideoPreset: 'HighestQuality',\n    includeExif: true,\n    cropperStatusBarColor: 'white',\n    cropperToolbarColor: 'white',\n    cropperActiveWidgetColor: 'white',\n    cropperToolbarWidgetColor: '#3498DB'\n  })\n  return image\n}\n\nconst getIMG = async (fileName?: string) => {\n  const defaultImg = require('../../assets/defaultImage/defaultProfileImage.png')\n  if (fileName) {\n    try {\n      return await storage().ref(fileName).getDownloadURL()\n    } catch (error) {\n      return defaultImg\n    }\n  } else {\n    return defaultImg\n  }\n}\n\nconst uploadImg = async (image: { path: string }) => {\n  const photo = await fetch(image.path)\n  const photoBlob = await photo.blob()\n  const fileName = `images/${nanoid(13)}${image.path.substring(\n    image.path.lastIndexOf('/') + 1\n  )}`\n  const reference = storage().ref(fileName)\n  await reference.put(photoBlob)\n  return fileName\n}\n\nfunction getUid() {\n  return auth().currentUser?.uid\n}\n\ninterface getTimeT {\n  lastTime: number\n  type?: '' | '-short'\n}\n\nfunction getTimeStamp({ lastTime, type = '' }: getTimeT) {\n  const dateNow = Date.now()\n  let date: Date = new Date(lastTime)\n\n  const day = 86400000\n  const difference = dateNow - lastTime\n\n  if (difference <= 20000) {\n    return i18next.t(`timestamps${type}.now`)\n  } else if (difference <= day) {\n    return i18next.t(`timestamps${type}.today`)\n  } else if (difference <= day * 2) {\n    return i18next.t(`timestamps${type}.yday`)\n  } else if (difference <= 30 * day) {\n    const days = Math.floor(difference / day)\n    return `${days}${i18next.t(`timestamps${type}.d`)}`\n  } else if (difference < 12 * 30 * day) {\n    const month = Math.floor(difference / (day * 30))\n    return `${month}${i18next.t(`timestamps${type}.m`)}`\n  } else {\n    return `${date.getHours()}:${date.getMinutes()} · ${date.getDate()}/${date.getMonth()}/${date\n      .getFullYear()\n      .toString()\n      .substr(2, 2)}`\n  }\n}\n\nconst onSignIn = async (\n  user: FirebaseAuthTypes.User,\n  isKeychain?: boolean,\n  linkTo?: any\n) => {\n  try {\n    actionsDice.setOnline(true)\n    if (user.emailVerified) {\n      const prof = await getProfile()\n      if (prof?.status === 'ban') {\n        !isKeychain && accountHasBanAlert()\n        return\n      }\n      if (!prof?.firstGame && !prof?.lastName) {\n        navigate('SIGN_UP_USERNAME', { email: user.email })\n      } else if (!prof.avatar) {\n        navigate('SIGN_UP_AVATAR')\n      } else if (!prof.intention) {\n        navigate('CHANGE_INTENTION_SCREEN', {\n          blockGoBack: true,\n          title: i18next.t('online-part.createIntention')\n        })\n      } else {\n        navigate('MAIN', { screen: 'TAB_BOTTOM_0' })\n        if (!prof.isReported) {\n          OpenPlanReportModal(prof.plan)\n        } else if (MessagingStore.path) {\n          linkTo(MessagingStore.path)\n          MessagingStore.path = ''\n        }\n        const reference = getFireBaseRef(`/online/${prof.owner}`)\n        reference.set(true)\n        reference.onDisconnect().set(false)\n        OnlinePlayer.getProfile()\n        fetchBusinesses()\n      }\n    } else {\n      navigate('CONFIRM_SIGN_UP', {\n        email: user.email\n      })\n    }\n  } catch (error) {\n    captureException(error, 'onSignIn')\n  }\n}\n\nconst checkVersion = async (minVersion: string) => {\n  if (semver.lt(version, minVersion)) {\n    OpenUpdateVersionModal()\n  }\n}\n\nexport {\n  updateFlagEmojiIfNeed,\n  uploadImg,\n  updatePlan,\n  updateProfName,\n  getIMG,\n  getImagePicker,\n  getProfile,\n  createHistory,\n  createProfile,\n  isLoggedIn,\n  resetHistory,\n  getFireBaseRef,\n  onWin,\n  onStart,\n  resetPlayer,\n  getTimeStamp,\n  getUid,\n  startStepTimer,\n  onSignIn,\n  checkVersion,\n  updateIntention\n}\n","resolvedModuleNames":["/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/package.json","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/src/store/PostStore.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/DiceStore.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/OfflinePlayers.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/store/BadgeAndroidStore.ts","/Users/playra/leela/src/store/SubscribeStore.ts"]}],["/Users/playra/leela/src/store/OnlinePlayer.ts",{"fileContent":"import auth from '@react-native-firebase/auth'\nimport firestore from '@react-native-firebase/firestore'\nimport storage from '@react-native-firebase/storage'\nimport { makeAutoObservable } from 'mobx'\nimport * as Keychain from 'react-native-keychain'\nimport i18next from '../i18n'\n\nimport { upStepOnline } from './helper'\nimport { delTokenOnSignOut } from './MessagingStore'\n\nimport { DiceStore, actionSubscribeStore, actionsDice } from './'\nimport { captureException, navigate } from '../constants'\nimport {\n  getFireBaseRef,\n  getIMG,\n  getImagePicker,\n  getProfile,\n  resetHistory,\n  resetPlayer,\n  updatePlan,\n  uploadImg\n} from '../screens/helper'\nimport { HistoryT, statusT } from '../types'\n\nconst initProfile = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  intention: ''\n}\n\nconst initHistory = () => [\n  {\n    createDate: Date.now(),\n    plan: 68,\n    count: 0,\n    status: 'start'\n  }\n]\n\nexport const OnlinePlayer = makeAutoObservable<Istore>({\n  store: {\n    start: false,\n    finish: false,\n    stepTime: 0,\n    timeText: ' ',\n    canGo: false,\n    plan: 68,\n    // addons\n    firstGame: false,\n    loadingProf: true,\n    history: initHistory(),\n    isReported: true,\n    avatar: '',\n    profile: initProfile,\n    isPosterLoading: false\n  },\n  async resetGame(): Promise<void> {\n    try {\n      OnlinePlayer.store = {\n        ...OnlinePlayer.store,\n        start: false,\n        finish: false,\n        plan: 68,\n        history: initHistory()\n      }\n      await resetPlayer()\n      await resetHistory()\n      await updatePlan(68)\n      DiceStore.online = false\n    } catch (err) {\n      captureException(err, 'resetGame')\n    }\n  },\n  async SignOut(): Promise<void> {\n    try {\n      const userUid = auth().currentUser?.uid\n      await getFireBaseRef(`/online/${userUid}`).set(false)\n      await delTokenOnSignOut()\n      OnlinePlayer.store = {\n        ...OnlinePlayer.store,\n        profile: initProfile,\n        avatar: '',\n        start: false,\n        finish: false,\n        plan: 68,\n        history: initHistory(),\n        canGo: false,\n        stepTime: 0,\n        timeText: ' ',\n        loadingProf: true\n      }\n      actionsDice.resetPlayer()\n      await Keychain.resetInternetCredentials('auth')\n      await auth().signOut()\n      actionSubscribeStore.resetStore()\n      DiceStore.online = false\n      navigate('HELLO')\n    } catch (err) {\n      captureException(err, 'SignOut')\n    }\n  },\n  async SignOutToOffline(): Promise<void> {\n    try {\n      OnlinePlayer.store = {\n        ...OnlinePlayer.store,\n        profile: initProfile,\n        avatar: '',\n        start: false,\n        finish: false,\n        plan: 68,\n        history: initHistory(),\n        canGo: false,\n        stepTime: 0,\n        timeText: ' ',\n        loadingProf: true\n      }\n      actionsDice.resetPlayer()\n      actionSubscribeStore.resetStore()\n      await auth().signOut()\n    } catch (err) {\n      captureException(err, 'SignOutToOffline')\n    }\n  },\n  async getProfile(): Promise<void> {\n    try {\n      OnlinePlayer.store.loadingProf = true\n      const curProf = await getProfile()\n      if (curProf) {\n        OnlinePlayer.store = {\n          ...OnlinePlayer.store,\n          plan: curProf.plan,\n          start: curProf.start,\n          finish: curProf.finish,\n          firstGame: curProf.firstGame,\n          profile: {\n            firstName: curProf.firstName,\n            lastName: curProf.lastName,\n            email: curProf.email,\n            intention: curProf.intention || ''\n          },\n          isReported: curProf.isReported,\n          flagEmoji: curProf.flagEmoji,\n          stepTime: curProf.lastStepTime,\n          canGo: Date.now() - curProf.lastStepTime >= 86400000,\n          status: curProf?.status,\n          history: curProf.history\n            .sort((a, b) => b.createDate - a.createDate)\n            .slice(0, 30)\n        }\n        if (curProf.plan === 68 && !curProf.finish) {\n          actionsDice.setMessage(i18next.t('sixToBegin'))\n        } else {\n          actionsDice.setMessage(' ')\n        }\n        OnlinePlayer.store.avatar = await getIMG(curProf.avatar)\n        DiceStore.startGame = curProf.start\n      }\n      OnlinePlayer.store.loadingProf = false\n    } catch (error) {\n      captureException(error, 'getProfile')\n    }\n  },\n  async uploadImage(): Promise<void> {\n    try {\n      const image = await getImagePicker()\n      if (image) {\n        try {\n          const fileName = await uploadImg(image)\n          const prevImgUrl = auth().currentUser?.photoURL\n          if (prevImgUrl) {\n            await storage().ref(prevImgUrl).delete()\n          }\n          await auth().currentUser?.updateProfile({\n            photoURL: fileName\n          })\n          await firestore()\n            .collection('Profiles')\n            .doc(auth().currentUser?.uid)\n            .update({\n              avatar: fileName\n            })\n          OnlinePlayer.store.avatar = await getIMG(fileName)\n        } catch (error) {\n          captureException(error, 'uploadImage')\n        }\n      }\n    } catch (error) {\n      captureException(error, 'uploadImage')\n    }\n  },\n  async updateStep(): Promise<void> {\n    upStepOnline()\n  },\n  getLeftTime(lastTime) {\n    const day = 86400000\n    const hour = 3600000\n    const min = 60000\n    const sec = 1000\n    const dateNow = Date.now()\n    const passTime = dateNow - lastTime\n    const difference = day - passTime\n\n    if (difference <= 0) {\n      return '0'\n    } else if (difference < min) {\n      const secCount = Math.round(difference / sec)\n      return `${secCount} ${i18next.t('timestamps-short.sec')}`\n    } else if (difference < hour) {\n      const minCount = Math.round(difference / min)\n      return `${minCount} ${i18next.t('timestamps-short.min')}`\n    } else {\n      const hourCount = Math.round(difference / hour)\n      return `${hourCount} ${i18next.t('timestamps-short.h')}`\n    }\n  },\n  async deleteUser() {\n    try {\n      const userUid = auth().currentUser?.uid\n      await getFireBaseRef(`/online/${userUid}`).set(false)\n      await delTokenOnSignOut()\n      let user = auth().currentUser\n      user === null\n        ? null\n        : user.delete().catch((error) => captureException(error, 'deleteUser'))\n      navigate('HELLO')\n    } catch (err) {\n      captureException(err, 'deleteUser')\n    }\n  }\n})\n\ninterface Istore {\n  store: OnlinePlayerStore\n  resetGame: () => Promise<void>\n  SignOut: () => Promise<void>\n  getProfile: () => Promise<void>\n  uploadImage: () => Promise<void>\n  updateStep: () => Promise<void>\n  SignOutToOffline: () => Promise<void>\n  getLeftTime: (lastTime: number) => string\n  deleteUser: () => Promise<void>\n}\n\ninterface OnlinePlayerStore {\n  // game\n  start: boolean\n  finish: boolean\n  stepTime: number\n  timeText: string\n  canGo: boolean\n  plan: number\n  // addons\n  firstGame: boolean\n  loadingProf: boolean\n  history: HistoryT[]\n  isReported: boolean\n  avatar: string\n  profile: {\n    firstName: string\n    lastName: string\n    email: string\n    intention: string\n  }\n  isPosterLoading: boolean\n  flagEmoji?: string\n  status?: statusT\n}\n","resolvedModuleNames":["/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/helper.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/src/store/DiceStore.ts","/Users/playra/leela/src/store/PostStore.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/OfflinePlayers.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/store/BadgeAndroidStore.ts","/Users/playra/leela/src/store/SubscribeStore.ts","/Users/playra/leela/package.json"]}],["/Users/playra/leela/src/store/helper.ts",{"fileContent":"import i18next from '../i18n'\n\nimport { DiceStore, actionsDice } from './DiceStore'\n\nimport { OfflinePlayers, OnlinePlayer } from './'\nimport { captureException, navigate } from '../constants'\nimport { createHistory, onStart, onWin, updatePlan } from '../screens/helper'\n\ninterface historyI {\n  count: number\n  plan: number\n  status: string\n}\n\ninterface stepT {\n  plan: number\n  history: historyI\n  stepCount: number\n  id?: number\n}\n\n// ONLINE\nasync function upFuncOnline(step: stepT) {\n  const { plan, history, stepCount } = step\n  const historyObj = { ...history, createDate: Date.now() }\n  try {\n    await createHistory(historyObj)\n    await updatePlan(plan)\n    OnlinePlayer.store.history.unshift(historyObj)\n    OnlinePlayer.store.plan = plan\n    if (stepCount !== 6 || plan === 68) {\n      navigate('PLANS_DETAIL_SCREEN', {\n        plan,\n        report: true\n      })\n    }\n    if (plan === 68) {\n      actionsDice.setMessage('liberation')\n      await onWin()\n      OnlinePlayer.store.start = false\n      OnlinePlayer.store.finish = true\n    }\n  } catch (err) {\n    captureException(err, 'upFuncOnline')\n  }\n}\n\nexport function upStepOnline() {\n  if (!OnlinePlayer.store.canGo) {\n    return\n  }\n  const count = DiceStore.count\n  const plan = OnlinePlayer.store.plan + count\n  if (count === 6) {\n    actionsDice.setMessage(`${i18next.t('oneMoreThrow')}`)\n  } else {\n    actionsDice.setMessage(' ')\n  }\n  const isFinished = OnlinePlayer.store.finish\n  const isStart = OnlinePlayer.store.start\n\n  function handleStart() {\n    OnlinePlayer.store.start = true\n    onStart()\n  }\n  const step = entities({\n    isFinished,\n    plan,\n    isStart,\n    stepCount: count,\n    handleStart\n  })\n  if (step) {\n    upFuncOnline(step)\n  }\n}\n\n// OFFLINE\nconst upFuncOffline = async (step: stepT): Promise<void> => {\n  const { plan, history, id } = step\n  const historyObj = { ...history, createDate: Date.now() }\n  if (id !== undefined) {\n    OfflinePlayers.store.histories[id].unshift(historyObj)\n    OfflinePlayers.store.plans[id] = plan\n    if (plan === 68) {\n      DiceStore.finishArr = DiceStore.finishArr.map(\n        (x: boolean, index: number) => (index === id ? (x = false) : x)\n      )\n      actionsDice.setMessage('liberation')\n      OfflinePlayers.store.start[id] = false\n      OfflinePlayers.store.finish[id] = true\n    }\n  }\n}\n\nexport const upStepOffline = (id: number) => {\n  const count = DiceStore.count\n  const plan = OfflinePlayers.store.plans[id] + count\n  if (count === 6) {\n    actionsDice.setMessage(`${i18next.t('oneMoreThrow')}`)\n  } else {\n    actionsDice.setMessage(' ')\n    actionsDice.changePlayer()\n  }\n  const isFinished = OfflinePlayers.store.finish[id]\n  const isStart = OfflinePlayers.store.start[id]\n  function handleStart() {\n    OfflinePlayers.store.start[id] = true\n  }\n  const step = entities({\n    isFinished,\n    plan,\n    isStart,\n    stepCount: count,\n    handleStart\n  })\n  if (step) {\n    upFuncOffline({ ...step, id })\n  }\n}\n\ninterface entitiesT {\n  plan: number\n  stepCount: number\n  isFinished: boolean\n  isStart: boolean\n  handleStart: () => void\n}\n\nconst entities = ({\n  plan,\n  stepCount,\n  isFinished,\n  isStart,\n  handleStart\n}: entitiesT) => {\n  if (isStart) {\n    const lib = { count: stepCount, plan: 68, status: 'liberation' }\n    switch (true) {\n      case plan > 72:\n        return undefined\n      // snakes\n      case plan === 72:\n        const obj51 = { count: stepCount, plan: 51, status: 'snake' }\n        return { plan: 51, history: obj51, stepCount }\n      case plan === 63:\n        const obj2 = { count: stepCount, plan: 2, status: 'snake' }\n        return { plan: 2, history: obj2, stepCount }\n      case plan === 61:\n        const obj13 = { count: stepCount, plan: 13, status: 'snake' }\n        return { plan: 13, history: obj13, stepCount }\n      case plan === 55:\n        const obj3 = { count: stepCount, plan: 3, status: 'snake' }\n        return { plan: 3, history: obj3, stepCount }\n      case plan === 52:\n        const obj35 = { count: stepCount, plan: 35, status: 'snake' }\n        return { plan: 35, history: obj35, stepCount }\n      case plan === 44:\n        const obj9 = { count: stepCount, plan: 9, status: 'snake' }\n        return { plan: 9, history: obj9, stepCount }\n      case plan === 29:\n        const obj6 = { count: stepCount, plan: 6, status: 'snake' }\n        return { plan: 6, history: obj6, stepCount }\n      case plan === 24:\n        const obj7 = { count: stepCount, plan: 7, status: 'snake' }\n        return { plan: 7, history: obj7, stepCount }\n      case plan === 16:\n        const obj4 = { count: stepCount, plan: 4, status: 'snake' }\n        return { plan: 4, history: obj4, stepCount }\n      case plan === 12:\n        const obj8 = { count: stepCount, plan: 8, status: 'snake' }\n        return { plan: 8, history: obj8, stepCount }\n      // arrows\n      case plan === 10:\n        const obj23 = { count: stepCount, plan: 23, status: 'arrow' }\n        return { plan: 23, history: obj23, stepCount }\n      case plan === 17:\n        const obj69 = { count: stepCount, plan: 69, status: 'arrow' }\n        return { plan: 69, history: obj69, stepCount }\n      case plan === 20:\n        const obj32 = { count: stepCount, plan: 32, status: 'arrow' }\n        return { plan: 32, history: obj32, stepCount }\n      case plan === 22:\n        const obj60 = { count: stepCount, plan: 60, status: 'arrow' }\n        return { plan: 60, history: obj60, stepCount }\n      case plan === 27:\n        const obj41 = { count: stepCount, plan: 41, status: 'arrow' }\n        return { plan: 41, history: obj41, stepCount }\n      case plan === 28:\n        const obj50 = { count: stepCount, plan: 50, status: 'arrow' }\n        return { plan: 50, history: obj50, stepCount }\n      case plan === 37:\n        const obj66 = { count: stepCount, plan: 66, status: 'arrow' }\n        return { plan: 66, history: obj66, stepCount }\n      case plan === 45:\n        const obj67 = { count: stepCount, plan: 67, status: 'arrow' }\n        return { plan: 67, history: obj67, stepCount }\n      case plan === 46:\n        const obj62 = { count: stepCount, plan: 62, status: 'arrow' }\n        return { plan: 62, history: obj62, stepCount }\n      // final\n      case plan === 54:\n        return { plan: 68, history: lib, stepCount }\n      case plan === 68:\n        return { plan: 68, history: lib, stepCount }\n      default: {\n        const obj = { count: stepCount, plan, status: 'cube' }\n        return { plan: plan, history: obj, stepCount }\n      }\n    }\n  } else if (stepCount === 6 && !isFinished) {\n    const obj6 = { count: stepCount, plan: 6, status: 'cube' }\n\n    handleStart()\n    return { plan: 6, history: obj6, stepCount }\n  }\n}\n","resolvedModuleNames":["/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/DiceStore.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/PostStore.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/OfflinePlayers.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/store/BadgeAndroidStore.ts","/Users/playra/leela/src/store/SubscribeStore.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/package.json"]}],["/Users/playra/leela/src/store/DiceStore.ts",{"fileContent":"import AsyncStorage from '@react-native-async-storage/async-storage'\nimport { autorun, makeAutoObservable } from 'mobx'\nimport { makePersistable } from 'mobx-persist-store'\nimport i18next from '../i18n'\n\nimport { OnlinePlayer } from './OnlinePlayer'\nimport { storageAdapter } from './storageAdapter'\n\nconst DiceStore = makeAutoObservable({\n  init: false,\n  online: false,\n  count: 6,\n  startGame: false,\n  players: 1,\n  message: ' ',\n  topMessage: ' ',\n  multi: 0,\n  rate: false,\n  finishArr: [] as boolean[]\n})\nautorun(() => {\n  if (OnlinePlayer && OnlinePlayer.store) {\n    const { isReported, canGo, timeText } = OnlinePlayer.store\n    if (i18next.isInitialized) {\n      const textTopMess = DiceStore.online\n        ? !isReported\n          ? i18next.t('online-part.notReported')\n          : canGo\n          ? i18next.t('takeStep')\n          : `${i18next.t('nextStep')}: ${timeText}`\n        : `${i18next.t('playerTurn')} # ${DiceStore.players}`\n      DiceStore.topMessage = textTopMess\n    }\n  }\n})\n\nconst actionsDice = {\n  setOnline(bool: boolean): void {\n    DiceStore.online = bool\n  },\n  random(): void {\n    const getRandomNumber = () => Math.floor(Math.random() * 6) + 1\n    let get = getRandomNumber()\n    if (get === DiceStore.count) {\n      get = getRandomNumber()\n    }\n    DiceStore.count = get\n  },\n  setPlayers(players: number): void {\n    DiceStore.multi = players\n    DiceStore.startGame = true\n    DiceStore.finishArr = [true, true, true, true, true, true].slice(0, players)\n  },\n  changePlayer(): void {\n    const arr = DiceStore.finishArr\n    const newArr = arr.slice(DiceStore.players, DiceStore.multi)\n    const lengthArray = newArr.length\n\n    if (DiceStore.multi === DiceStore.players) {\n      DiceStore.players = arr.indexOf(true) + 1\n    } else if (newArr.indexOf(true) === -1) {\n      DiceStore.players = arr.indexOf(true) + 1\n    } else if (newArr.indexOf(true) === 0) {\n      DiceStore.players = DiceStore.players + 1\n    } else if (newArr.indexOf(true) === 1) {\n      DiceStore.players = DiceStore.multi - lengthArray + 2\n    } else if (newArr.indexOf(true) === 2) {\n      DiceStore.players = DiceStore.multi - lengthArray + 3\n    } else if (newArr.indexOf(true) === 3) {\n      DiceStore.players = DiceStore.multi - lengthArray + 4\n    } else {\n      DiceStore.players = DiceStore.multi - lengthArray + 5\n    }\n  },\n  async resetPlayer(): Promise<void> {\n    DiceStore.players = 1\n    DiceStore.startGame = false\n    DiceStore.init = false\n    DiceStore.finishArr = DiceStore.finishArr.map((x: boolean) => x === true)\n    await AsyncStorage.setItem('@init', 'false')\n  },\n  setMessage(mess: string): void {\n    DiceStore.message = mess\n  },\n  setRate(rate: boolean): void {\n    DiceStore.rate = rate\n  },\n  async init(): Promise<void> {\n    await AsyncStorage.setItem('@init', 'true')\n  }\n}\n\nmakePersistable(DiceStore, {\n  name: 'DiceStore',\n  properties: [\n    'count',\n    'startGame',\n    'players',\n    'message',\n    'multi',\n    'finishArr',\n    'init',\n    'rate',\n    'online'\n  ],\n  storage: storageAdapter\n})\n\nexport { DiceStore, actionsDice }\n","resolvedModuleNames":["/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/storageAdapter.ts","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/src/store/helper.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/types.ts"]}],["/Users/playra/leela/src/store/MessagingStore.ts",{"fileContent":"import auth from '@react-native-firebase/auth'\nimport firestore from '@react-native-firebase/firestore'\nimport messaging from '@react-native-firebase/messaging'\nimport { makeAutoObservable } from 'mobx'\nimport { makePersistable } from 'mobx-persist-store'\n\nimport { captureException } from '../constants'\nimport { storageAdapter } from './storageAdapter'\n\nexport const MessagingStore = makeAutoObservable({\n  path: ''\n})\n\nmakePersistable(MessagingStore, {\n  name: 'MessagingStore',\n  properties: ['path'],\n  storage: storageAdapter\n})\n\nconst fetchBusinesses = () => {\n  const requestUserPermission = async () => {\n    const authStatus = await messaging().requestPermission()\n    const enabled =\n      authStatus === messaging.AuthorizationStatus.AUTHORIZED ||\n      authStatus === messaging.AuthorizationStatus.PROVISIONAL\n\n    if (enabled) {\n      messaging()\n        .getToken()\n        .then((token) => {\n          return saveTokenToDatabase(token)\n        })\n\n      return messaging().onTokenRefresh((token) => {\n        saveTokenToDatabase(token)\n      })\n    }\n  }\n  requestUserPermission()\n}\n\nconst saveTokenToDatabase = async (token: string) => {\n  const userUid = auth().currentUser?.uid\n  try {\n    if (userUid) {\n      await firestore()\n        .collection('Profiles')\n        .doc(userUid)\n        .update({\n          tokens: firestore.FieldValue.arrayUnion(token)\n        })\n    }\n  } catch (e) {\n    captureException(e, 'saveTokenToDatabase')\n  }\n}\n\nconst delTokenOnSignOut = async () => {\n  const userUid = auth().currentUser?.uid\n  try {\n    const token = await messaging().getToken()\n    await firestore()\n      .collection('Profiles')\n      .doc(userUid)\n      .update({\n        tokens: firestore.FieldValue.arrayRemove(token)\n      })\n  } catch (error) {\n    captureException(error, 'delTokenOnSignOut')\n  }\n}\n\nexport { saveTokenToDatabase, fetchBusinesses, delTokenOnSignOut }\n","resolvedModuleNames":["/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/store/storageAdapter.ts","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/types.ts"]}],["/Users/playra/leela/src/store/OtherPlayers.ts",{"fileContent":"import { FirebaseFirestoreTypes } from '@react-native-firebase/firestore'\nimport { makeAutoObservable } from 'mobx'\n\nimport { captureException } from '../constants'\nimport { getFireBaseRef, getIMG } from '../screens/helper'\nimport { OtherUsersT, UserT } from '../types'\n\ninterface storeI {\n  players: OtherUsersT[]\n  online: OtherUsersT[]\n}\n\ninterface GetOtherI {\n  snapshot?: FirebaseFirestoreTypes.QuerySnapshot<FirebaseFirestoreTypes.DocumentData>\n}\n\nexport const OtherPlayers = {\n  store: makeAutoObservable<storeI>({\n    players: [],\n    online: []\n  }),\n  getOtherProf: async ({ snapshot }: GetOtherI) => {\n    if (snapshot) {\n      const otherData: any = await Promise.all(\n        snapshot.docs.map(async (a) => {\n          if (a.exists) {\n            const data: UserT = a.data() as UserT\n            let isOnline = false\n            await getFireBaseRef(`/online/${data.owner}`)\n              .once('value')\n              .then(async (snapshotOnline) => {\n                isOnline = snapshotOnline.val()\n              })\n              .catch((err) => captureException(err, 'getOtherProf'))\n            const result: OtherUsersT = {\n              email: data.email,\n              plan: data.plan,\n              firstName: data.firstName,\n              lastName: data.lastName,\n              avatar: data.avatar ? await getIMG(data.avatar) : '',\n              owner: data.owner,\n              status: data.status,\n              isOnline\n            }\n\n            return result\n          }\n        })\n      )\n      if (otherData) {\n        OtherPlayers.store.players = otherData.filter(\n          (a: any) => a !== undefined\n        )\n      }\n      OtherPlayers.getOnlineProf()\n    }\n  },\n  getOnlineProf: async () => {\n    if (OtherPlayers.store.players.length > 0) {\n      OtherPlayers.store.online = OtherPlayers.store.players.filter(\n        (a) => a.isOnline\n      )\n    }\n  }\n}\n","resolvedModuleNames":["/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/package.json"]}],["/Users/playra/leela/src/store/OfflinePlayers.ts",{"fileContent":"import AsyncStorage from '@react-native-async-storage/async-storage'\nimport { makeAutoObservable } from 'mobx'\nimport { makePersistable } from 'mobx-persist-store'\nimport i18next from '../i18n'\n\nimport { upStepOffline } from './helper'\n\nimport { actionsDice } from './'\nimport { navigate } from '../constants'\nimport { HistoryT } from '../types'\nimport { storageAdapter } from './storageAdapter'\n\nexport const initStore = {\n  start: [false, false, false, false, false, false],\n  finish: [false, false, false, false, false, false],\n  plans: [68, 68, 68, 68, 68, 68],\n  histories: [\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }],\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }],\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }],\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }],\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }],\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }],\n    [{ createDate: Date.now(), plan: 68, count: 0, status: 'start' }]\n  ]\n}\n\nexport const OfflinePlayers = {\n  store: makeAutoObservable<OfflinePlayersI>({ ...initStore }),\n  async resetGame(): Promise<void> {\n    actionsDice.resetPlayer()\n    await AsyncStorage.clear()\n    /* вы подумаете тут можно это все заменить 1 строчкой:\n    `` OfflinePlayers.store = {...initStore} ``, а нет. Так\n    в persist-store результат не сохраняется */\n    OfflinePlayers.store.plans = initStore.plans\n    OfflinePlayers.store.start = initStore.start\n    OfflinePlayers.store.histories = initStore.histories\n    OfflinePlayers.store.finish = initStore.finish\n    navigate('HELLO')\n  },\n  startGame() {\n    actionsDice.setMessage(i18next.t('sixToBegin'))\n  },\n  updateStep(id: number): void {\n    upStepOffline(id)\n  }\n}\n\nmakePersistable(OfflinePlayers.store, {\n  name: 'OfflinePlayers',\n  properties: ['plans', 'start', 'histories', 'finish'],\n  storage: storageAdapter\n})\n\ninterface OfflinePlayersI {\n  start: boolean[]\n  finish: boolean[]\n  plans: number[]\n  histories: HistoryT[][]\n}\n","resolvedModuleNames":["/Users/playra/leela/src/i18n.ts","/Users/playra/leela/src/store/helper.ts","/Users/playra/leela/src/store/index.ts","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/types.ts","/Users/playra/leela/src/store/storageAdapter.ts","/Users/playra/leela/src/locales/ar/translation.json","/Users/playra/leela/src/locales/bn/translation.json","/Users/playra/leela/src/locales/en/translation.json","/Users/playra/leela/src/locales/fr/translation.json","/Users/playra/leela/src/locales/mr/translation.json","/Users/playra/leela/src/locales/ms/translation.json","/Users/playra/leela/src/locales/ru/translation.json","/Users/playra/leela/src/locales/te/translation.json","/Users/playra/leela/src/locales/tr/translation.json","/Users/playra/leela/src/locales/uk/translation.json","/Users/playra/leela/src/store/DiceStore.ts","/Users/playra/leela/src/screens/helper.ts","/Users/playra/leela/src/store/PostStore.ts","/Users/playra/leela/src/store/MessagingStore.ts","/Users/playra/leela/src/store/OnlinePlayer.ts","/Users/playra/leela/src/store/OfflinePlayers.ts","/Users/playra/leela/src/store/OtherPlayers.ts","/Users/playra/leela/src/store/BadgeAndroidStore.ts","/Users/playra/leela/src/store/SubscribeStore.ts"]}],["/Users/playra/leela/src/store/BadgeAndroidStore.ts",{"fileContent":"import { makeAutoObservable } from 'mobx'\nimport { makePersistable } from 'mobx-persist-store'\nimport { storageAdapter } from './storageAdapter'\n\nconst BadgeAndroidStore = makeAutoObservable({\n  count: 0\n})\n\nmakePersistable(BadgeAndroidStore, {\n  name: 'BadgeAndroidStore',\n  properties: ['count'],\n  storage: storageAdapter\n})\n\nexport { BadgeAndroidStore }\n","resolvedModuleNames":["/Users/playra/leela/src/store/storageAdapter.ts"]}],["/Users/playra/leela/src/store/SubscribeStore.ts",{"fileContent":"import { makeAutoObservable } from 'mobx'\nimport { makePersistable } from 'mobx-persist-store'\nimport { storageAdapter } from './storageAdapter'\n\nconst SubscribeStore = makeAutoObservable({\n  isBlockGame: false // defaut false\n})\n\nconst actionSubscribeStore = {\n  unBlock: async () => {\n    SubscribeStore.isBlockGame = false\n  },\n  blockGame: async () => {\n    SubscribeStore.isBlockGame = true\n  },\n  resetStore: async () => {\n    SubscribeStore.isBlockGame = false\n  }\n}\n\nmakePersistable(SubscribeStore, {\n  name: 'SubscribeStore',\n  properties: ['isBlockGame'],\n  storage: storageAdapter\n})\n\nexport { SubscribeStore, actionSubscribeStore }\n","resolvedModuleNames":["/Users/playra/leela/src/store/storageAdapter.ts"]}],["/Users/playra/leela/src/components/Pressable/index.tsx",{"fileContent":"import React from 'react'\n\nimport {\n  PressableStateCallbackType,\n  Pressable as RNPressable,\n  PressableProps as RNPressableProps,\n  StyleProp,\n  ViewStyle\n} from 'react-native'\n\ntype PressableProps = Omit<RNPressableProps, 'style'> & {\n  style?: StyleProp<ViewStyle>\n  pressedStyle?: StyleProp<ViewStyle>\n}\n\nconst Pressable: React.FC<PressableProps> = ({\n  children,\n  style,\n  pressedStyle,\n  ...props\n}) => {\n  const defaultPressedStyle: StyleProp<ViewStyle> = { opacity: 0.2 } // default Pressable-like press style\n\n  const handlePressStyle = ({\n    pressed\n  }: PressableStateCallbackType): StyleProp<ViewStyle> => {\n    if (pressed) {\n      return [\n        style,\n        pressedStyle || defaultPressedStyle\n      ] as StyleProp<ViewStyle>\n    }\n    return style as StyleProp<ViewStyle>\n  }\n\n  return (\n    <RNPressable style={handlePressStyle} {...props}>\n      {children}\n    </RNPressable>\n  )\n}\nexport { Pressable }\n","resolvedModuleNames":[]}],["/Users/playra/leela/src/store/storageAdapter.ts",{"fileContent":"import AsyncStorage from '@react-native-async-storage/async-storage'\n\ninterface StorageOptions {\n  ttl: number\n}\n\ninterface StorageAdapter extends StorageOptions {\n  getItem(key: string): Promise<any>\n  setItem(key: string, data: any): Promise<void>\n  removeItem(key: string): Promise<void>\n}\n\nconst ONE_YEAR_IN_MS = 365 * 24 * 60 * 60 * 1000 // milliseconds in a year\n\nexport const storageAdapter: StorageAdapter = {\n  getItem: async (key) => {\n    const item = JSON.parse((await AsyncStorage.getItem(key)) || '{}')\n    if (item && Date.now() - item.timestamp < ONE_YEAR_IN_MS) {\n      return item.data\n    }\n    await AsyncStorage.removeItem(key)\n    return null\n  },\n  setItem: async (key, data) => {\n    const item = {\n      timestamp: Date.now(),\n      data\n    }\n    AsyncStorage.setItem(key, JSON.stringify(item))\n  },\n  removeItem: async (key) => AsyncStorage.removeItem(key),\n  ttl: ONE_YEAR_IN_MS // время жизни данных в миллисекундах (1 год)\n}\n","resolvedModuleNames":[]}],["/Users/playra/leela/src/components/AppContainer/AppContainer.test.tsx",{"fileContent":"import React from 'react'\nimport { render, fireEvent } from '@testing-library/react-native'\n\nimport { AppContainer } from './'\nimport { Text } from 'react-native'\n\ndescribe('<AppContainer />', () => {\n  it('renders correctly', () => {\n    const { getByText } = render(\n      <AppContainer title=\"Test Title\">\n        <Text>Child Component</Text>\n      </AppContainer>\n    )\n\n    expect(getByText('Test Title')).toBeTruthy()\n    expect(getByText('Child Component')).toBeTruthy()\n  })\n\n  it('calls onPress when header is clicked', () => {\n    const onPressMock = jest.fn()\n\n    const { getByTestId } = render(\n      <AppContainer title=\"Test Title\" onPress={onPressMock}>\n        <Text>Child Component</Text>\n      </AppContainer>\n    )\n\n    fireEvent.press(getByTestId('header'))\n    expect(onPressMock).toHaveBeenCalled()\n  })\n\n  it('does not render header if header prop is false', () => {\n    const { queryByText } = render(\n      <AppContainer title=\"Test Title\" header={false}>\n        <Text>Child Component</Text>\n      </AppContainer>\n    )\n\n    expect(queryByText('Test Title')).toBeNull()\n  })\n})\n","resolvedModuleNames":["/Users/playra/leela/src/components/AppContainer/index.tsx","/Users/playra/leela/src/components/Background/index.tsx","/Users/playra/leela/src/components/Header/index.tsx"]}],["/Users/playra/leela/src/components/AppContainer/index.tsx",{"fileContent":"import React from 'react'\nimport { StyleSheet, View } from 'react-native'\n\nimport { Background } from '../Background'\nimport { Header } from '../Header'\n\ninterface AppContainerT {\n  iconLeft?: string | null\n  colorLeft?: string\n  onPress?: () => void\n  onPressRight?: () => void\n  iconRight?: string | null\n  children: React.ReactNode\n  message?: string\n  title?: string\n  displayStatus?: boolean\n  enableBackgroundBottomInsets?: boolean\n  enableBackgroundTopInsets?: boolean\n  header?: boolean\n  iconLeftOpacity?: number\n  textAlign?: 'center' | 'auto' | 'left' | 'right' | 'justify'\n  status?: 'bg' | 'clean' | '1x1'\n  hidestar?: boolean\n}\n\nexport function AppContainer({\n  iconLeft = null,\n  onPress,\n  onPressRight,\n  header = true,\n  iconRight = null,\n  children,\n  title,\n  enableBackgroundBottomInsets,\n  enableBackgroundTopInsets,\n  displayStatus,\n  iconLeftOpacity = 1,\n  textAlign = 'left',\n  status,\n  hidestar = true\n}: AppContainerT) {\n  return (\n    <View style={styles.container}>\n      {title && header && (\n        <Header\n          displayStatus={displayStatus}\n          textAlign={textAlign}\n          title={title}\n          onPress={onPress}\n          iconLeftOpacity={iconLeftOpacity}\n          onPressRight={onPressRight}\n          iconLeft={iconLeft}\n          iconRight={iconRight}\n          hidestar={hidestar}\n        />\n      )}\n      <Background\n        enableTopInsets={enableBackgroundTopInsets}\n        enableBottomInsets={enableBackgroundBottomInsets}\n        status={status}\n      >\n        {children}\n      </Background>\n    </View>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    width: '100%',\n    height: '100%'\n  }\n})\n","resolvedModuleNames":["/Users/playra/leela/src/components/Background/index.tsx","/Users/playra/leela/src/components/Header/index.tsx","/Users/playra/leela/src/components/Background/images/index.ts","/Users/playra/leela/src/hooks/index.ts","/Users/playra/leela/src/providers/RevenueCatProvider.tsx","/Users/playra/leela/src/components/index.ts","/Users/playra/leela/src/constants.ts","/Users/playra/leela/src/components/Pressable/index.tsx","/Users/playra/leela/src/store/index.ts"]}],["/Users/playra/leela/src/components/Background/index.tsx",{"fileContent":"import React, { memo } from 'react'\n\nimport {\n  Image,\n  StyleProp,\n  StyleSheet,\n  View,\n  ViewStyle,\n  useWindowDimensions\n} from 'react-native'\nimport { useSafeAreaInsets } from 'react-native-safe-area-context'\n\nimport { ICONS } from './images'\n\nimport { useImageAspect } from '../../hooks'\n\ninterface BackgroundT {\n  status?: 'bg' | 'clean' | '1x1'\n  children?: React.ReactNode\n  sourceImages?: [string, string] | [string]\n  style?: StyleProp<ViewStyle>\n  enableBottomInsets?: boolean\n  enableTopInsets?: boolean\n  paddingTop?: number\n}\n\nexport const Background = memo(\n  ({\n    status = 'bg',\n    sourceImages,\n    children,\n    style,\n    paddingTop = 0,\n    enableBottomInsets,\n    enableTopInsets\n  }: BackgroundT) => {\n    const images =\n      ICONS.find((x) => x.title === status)?.paths || sourceImages || []\n    const { bottom, top } = useSafeAreaInsets()\n\n    return (\n      <View style={styles.container}>\n        <View\n          style={[\n            styles.imgContainer,\n            style,\n            enableBottomInsets && { paddingBottom: bottom },\n            enableTopInsets && { paddingTop: top + paddingTop }\n          ]}\n        >\n          {images.map((img, id) => (\n            <RenderImagePart\n              img={img}\n              id={id}\n              images={images}\n              isUri={!!sourceImages}\n              key={`${img}-${id}`}\n            />\n          ))}\n        </View>\n        {children}\n      </View>\n    )\n  }\n)\n\ninterface RenderImagePartT {\n  img: string | any\n  id: number\n  isUri?: boolean\n  images: any[]\n}\n\nconst RenderImagePart = ({ img, id, isUri }: RenderImagePartT) => {\n  const { width: W } = useWindowDimensions()\n  const aspect = useImageAspect(img, !isUri)\n\n  const height = W / aspect\n  //const isOne = images?.length\n  const isTop = id === 0\n  return (\n    <View\n      style={[styles.subImgContainer, !isTop && styles.bottomImage]}\n      key={`${img}-${id}`}\n    >\n      <Image\n        source={isUri ? { uri: img } : img}\n        style={[styles.imgStyle, { height }]}\n      />\n    </View>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  bottomImage: {\n    justifyContent: 'flex-end'\n  },\n  imgContainer: {\n    position: 'absolute',\n    height: '100%',\n    width: '100%'\n  },\n  imgStyle: {\n    width: '100%',\n    marginVertical: 10\n  },\n  subImgContainer: {\n    flex: 1\n  }\n})\n","resolvedModuleNames":["/Users/playra/leela/src/components/Background/images/index.ts","/Users/playra/leela/src/hooks/index.ts","/Users/playra/leela/src/hooks/useExitModal.ts","/Users/playra/leela/src/hooks/useGameAndProfileIsOnline.ts","/Users/playra/leela/src/hooks/useKeychain.ts","/Users/playra/leela/src/hooks/useNetwork.ts","/Users/playra/leela/src/hooks/useTypedNavigation.ts","/Users/playra/leela/src/hooks/useNoBackHandler.ts","/Users/playra/leela/src/hooks/useLeftTimeForStep.ts","/Users/playra/leela/src/hooks/useHistoryData.ts","/Users/playra/leela/src/hooks/useMarkdownProps.tsx","/Users/playra/leela/src/hooks/useImageAspect.tsx"]}]]