b91ccd95198e107fa8fe04854cd89a8f












var _Platform = _interopRequireDefault(require("../Utilities/Platform"));
var PressabilityDebug = _interopRequireWildcard(require("../Pressability/PressabilityDebug"));
var _usePressability = _interopRequireDefault(require("../Pressability/usePressability"));
var _StyleSheet = _interopRequireDefault(require("../StyleSheet/StyleSheet"));
var _processColor = _interopRequireDefault(require("../StyleSheet/processColor"));
var _TextAncestor = _interopRequireDefault(require("./TextAncestor"));
var _TextNativeComponent = require("./TextNativeComponent");

var React = _interopRequireWildcard(require("react"));var _jsxRuntime = require("react/jsx-runtime");var _excluded = ["accessible", "allowFontScaling", "ellipsizeMode", "onLongPress", "onPress", "onPressIn", "onPressOut", "onResponderGrant", "onResponderMove", "onResponderRelease", "onResponderTerminate", "onResponderTerminationRequest", "onStartShouldSetResponder", "pressRetentionOffset", "suppressHighlighting"];var _this = this,_jsxFileName = "/Users/playra/leela/node_modules/react-native/Libraries/Text/Text.js";function _getRequireWildcardCache(nodeInterop) {if (typeof WeakMap !== "function") return null;var cacheBabelInterop = new WeakMap();var cacheNodeInterop = new WeakMap();return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {return nodeInterop ? cacheNodeInterop : cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj, nodeInterop) {if (!nodeInterop && obj && obj.__esModule) {return obj;}if (obj === null || typeof obj !== "object" && typeof obj !== "function") {return { default: obj };}var cache = _getRequireWildcardCache(nodeInterop);if (cache && cache.has(obj)) {return cache.get(obj);}var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {Object.defineProperty(newObj, key, desc);} else {newObj[key] = obj[key];}}}newObj.default = obj;if (cache) {cache.set(obj, newObj);}return newObj;}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];return arr2;}function _iterableToArrayLimit(arr, i) {var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];if (null != _i) {var _s,_e,_x,_r,_arr = [],_n = !0,_d = !1;try {if (_x = (_i = _i.call(arr)).next, 0 === i) {if (Object(_i) !== _i) return;_n = !1;} else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);} catch (err) {_d = !0, _e = err;} finally {try {if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;} finally {if (_d) throw _e;}}return _arr;}}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _objectWithoutProperties(source, excluded) {if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];}}return target;}function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}







var Text =


React.forwardRef(function (props, forwardedRef) {var _props$accessibilityS, _props$accessibilityS2;
  var
    accessible =















    props.accessible,allowFontScaling = props.allowFontScaling,ellipsizeMode = props.ellipsizeMode,onLongPress = props.onLongPress,onPress = props.onPress,_onPressIn = props.onPressIn,_onPressOut = props.onPressOut,_onResponderGrant = props.onResponderGrant,_onResponderMove = props.onResponderMove,_onResponderRelease = props.onResponderRelease,_onResponderTerminate = props.onResponderTerminate,onResponderTerminationRequest = props.onResponderTerminationRequest,onStartShouldSetResponder = props.onStartShouldSetResponder,pressRetentionOffset = props.pressRetentionOffset,suppressHighlighting = props.suppressHighlighting,restProps = _objectWithoutProperties(props, _excluded);

  var _useState = (0, React.useState)(false),_useState2 = _slicedToArray(_useState, 2),isHighlighted = _useState2[0],setHighlighted = _useState2[1];

  var _disabled =
  restProps.disabled != null ?
  restProps.disabled : (_props$accessibilityS =
  props.accessibilityState) == null ? void 0 : _props$accessibilityS.disabled;
  var _accessibilityState =
  _disabled !== ((_props$accessibilityS2 = props.accessibilityState) == null ? void 0 : _props$accessibilityS2.disabled) ? Object.assign({},
  props.accessibilityState, { disabled: _disabled }) :
  props.accessibilityState;

  var isPressable =
  (onPress != null ||
  onLongPress != null ||
  onStartShouldSetResponder != null) &&
  _disabled !== true;

  var initialized = useLazyInitialization(isPressable);
  var config = (0, React.useMemo)(
    function () {return (
        initialized ?
        {
          disabled: !isPressable,
          pressRectOffset: pressRetentionOffset,
          onLongPress: onLongPress,
          onPress: onPress,
          onPressIn: function onPressIn(event) {
            setHighlighted(!suppressHighlighting);
            _onPressIn == null ? void 0 : _onPressIn(event);
          },
          onPressOut: function onPressOut(event) {
            setHighlighted(false);
            _onPressOut == null ? void 0 : _onPressOut(event);
          },
          onResponderTerminationRequest_DEPRECATED:
          onResponderTerminationRequest,
          onStartShouldSetResponder_DEPRECATED: onStartShouldSetResponder
        } :
        null);},
    [
    initialized,
    isPressable,
    pressRetentionOffset,
    onLongPress,
    onPress,
    _onPressIn,
    _onPressOut,
    onResponderTerminationRequest,
    onStartShouldSetResponder,
    suppressHighlighting]

  );

  var eventHandlers = (0, _usePressability.default)(config);
  var eventHandlersForText = (0, React.useMemo)(
    function () {return (
        eventHandlers == null ?
        null :
        {
          onResponderGrant: function onResponderGrant(event) {
            eventHandlers.onResponderGrant(event);
            if (_onResponderGrant != null) {
              _onResponderGrant(event);
            }
          },
          onResponderMove: function onResponderMove(event) {
            eventHandlers.onResponderMove(event);
            if (_onResponderMove != null) {
              _onResponderMove(event);
            }
          },
          onResponderRelease: function onResponderRelease(event) {
            eventHandlers.onResponderRelease(event);
            if (_onResponderRelease != null) {
              _onResponderRelease(event);
            }
          },
          onResponderTerminate: function onResponderTerminate(event) {
            eventHandlers.onResponderTerminate(event);
            if (_onResponderTerminate != null) {
              _onResponderTerminate(event);
            }
          },
          onClick: eventHandlers.onClick,
          onResponderTerminationRequest:
          eventHandlers.onResponderTerminationRequest,
          onStartShouldSetResponder: eventHandlers.onStartShouldSetResponder
        });},
    [
    eventHandlers,
    _onResponderGrant,
    _onResponderMove,
    _onResponderRelease,
    _onResponderTerminate]

  );


  var selectionColor =
  restProps.selectionColor == null ?
  null :
  (0, _processColor.default)(restProps.selectionColor);

  var style = restProps.style;
  if (__DEV__) {
    if (PressabilityDebug.isEnabled() && onPress != null) {
      style = _StyleSheet.default.compose(restProps.style, {
        color: 'magenta'
      });
    }
  }

  var numberOfLines = restProps.numberOfLines;
  if (numberOfLines != null && !(numberOfLines >= 0)) {
    console.error("'numberOfLines' in <Text> must be a non-negative number, received: " +
    numberOfLines + ". The value will be set to 0."
    );
    numberOfLines = 0;
  }

  var hasTextAncestor = (0, React.useContext)(_TextAncestor.default);

  var _accessible = _Platform.default.select({
    ios: accessible !== false,
    default: accessible
  });

  return hasTextAncestor ?
  (0, _jsxRuntime.jsx)(_TextNativeComponent.NativeVirtualText, Object.assign({},
  restProps,
  eventHandlersForText, {
    isHighlighted: isHighlighted,
    isPressable: isPressable,
    numberOfLines: numberOfLines,
    selectionColor: selectionColor,
    style: style,
    ref: forwardedRef })
  ) :

  (0, _jsxRuntime.jsx)(_TextAncestor.default.Provider, { value: true, children:
    (0, _jsxRuntime.jsx)(_TextNativeComponent.NativeText, Object.assign({},
    restProps,
    eventHandlersForText, {
      disabled: _disabled,
      accessible: _accessible,
      accessibilityState: _accessibilityState,
      allowFontScaling: allowFontScaling !== false,
      ellipsizeMode: ellipsizeMode != null ? ellipsizeMode : 'tail',
      isHighlighted: isHighlighted,
      numberOfLines: numberOfLines,
      selectionColor: selectionColor,
      style: style,
      ref: forwardedRef })
    ) }
  );

});

Text.displayName = 'Text';






function useLazyInitialization(newValue) {
  var _useState3 = (0, React.useState)(newValue),_useState4 = _slicedToArray(_useState3, 2),oldValue = _useState4[0],setValue = _useState4[1];
  if (!oldValue && newValue) {
    setValue(newValue);
  }
  return oldValue;
}

module.exports = Text;